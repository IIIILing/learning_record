
# Github入门与实践1.0

开始学习《github入门与实战》

1.GitHub 是为开发者提供 Git 仓库的托管服务。这是一个让开发者与
朋友、同事、同学及陌生人共享代码的完美场所

2.在 Git 中，开发者将源代码存入名叫“Git 仓库”的资料库中
并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务

3.Pull Request 是指开发者在本地对源代码进行更改后，向 GitHub 中托管的 Git 仓库请求合并的功能。

4.GitHub 快捷的环境为开发者带来的合作伙伴，并不只局限于自己团队内部。只要将感兴趣的仓库添加至 Watch 中，就可以在 News Feed 查看该仓库的相关信息

## Git的导入

1.Git 属于分散型版本管理系统，是为版本管理而设计的软件
2.集中型仓库
集中型将所有数据集中存放在服务器当中，有便于管理的优点。
但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，
开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到最新的源代码了。

3.分散型仓库（git）
GitHub 将仓库 Fork 给了每一个用户。
Fork 就是将 GitHub 的某个特定仓库复制到自己的账户下。Fork 出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。

好处：分散型拥有多个仓库，相对而言稍显复杂。
由于本地的开发环境中就有仓库，所以开发者不必连接远程仓库就可以进行
开发。

## 使用github

1.设置SSHkey

SSH Key：secure shell key 安全外壳秘钥
用于安全访问远程服务器的加密密钥对
通常由私钥和公钥两个部分组成，被用于进行身份验证和加密通讯

私钥：私钥通常保存在你的计算机上，并且必须严格保密。它用于对传出的数据进行签名和对传入的数据进行解密。私钥相当于你的身份证，用来证明你是谁。

公钥：公钥是私钥的对应部分，可以公开分享。它被存储在你要访问的远程服务器上。远程服务器使用公钥验证与之通信的客户端的身份，并将数据加密后发送给客户端。公钥相当于你的访问卡，别人通过它来确认你的身份。

SSH密钥对通常用于以下场景：

远程登录（SSH登录）：使用SSH密钥对可以免密码登录远程服务器，提高登录的安全性。

Git和其他版本控制系统：SSH密钥对也可以用于身份验证，允许你与代码仓库进行安全通信，比如通过SSH连接到Git仓库。

安全文件传输：SSH密钥对也可以用于加密和解密文件的传输，保证数据的安全性。

个人私钥密码：github
公钥指纹：laeiVUh4qK/+d0VupemlAVHXQhGaRm/TwE3txJ9KQrk （rsa）
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU（ED255519）

id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥

当你第一次通过SSH连接到一个新的主机时，你的SSH客户端会询问你是否信任这个新的主机 这是因为SSH客户端无法确定这个新的主机是否是你期望连接的那个主机，还是一个试图冒充你期望连接的主机的恶意主机。

在这个过程中，SSH客户端会显示新主机的公钥指纹，并询问你是否要继续连接。如果你输入"yes"，那么你的SSH客户端将会把这个新主机的公钥指纹添加到known_hosts文件中，并且在以后的连接中不再询问你是否信任这个主机。

所以，当你看到这个提示，并且你确认你正在连接到你期望的主机时，你可以输入"yes"来继续连接。但是，请注意，你应该只在你确认你正在连接到你期望的主机时输入"yes"，如果你有任何疑虑，你应该检查这个新主机的公钥指纹，或者联系你的系统管理员

之前不知道为什么没有成功设置这个key
现在重新把key搞了一遍之后就已经设置成功了

### 使用社区功能和实际动手使用

1.Follow别人
2.创建仓库
(1)New repository

(2)初始设置

在 Repository name 栏中输入仓库的名称

Description 栏中可以设置仓库的说明。这一栏不是必需项，可以留空。

在 Initialize this repository with a README 选项上打钩，随后GitHub 会自动初始化仓库并设置 README 文件，让用户可以立刻clone 这个仓库。如果想向 GitHub 添加手中已有的 Git 仓库，建议不要
勾选，直接手动 push

(3)README

README.md 在初始化时已经生成好了。README.md 文件的内容会自动显示在仓库的首页当中

3.公开代码

(1)clone已有的代码

git clone -----------(此处填写ssh clone URL)

此时会被要求输入自己的密码

然后就可以把存储在github上的仓库克隆到自己这里

(2)自己把一份文件拉倒自己的仓库地址

然后输入git status查看状态

使用git add +文件名称（需要后缀）-------加入缓存区

使用git commit -m "加入自己关于这次更新的解释"------提交文件

使用git log查看提交日志

使用git push更新github上的仓库

## 深入使用git

### 基本操作

git init ------初始化仓库

在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。
文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。开发者可以通过这种方式获取以往的文件。具体操作指令我们将在后面详细解说。

git status---------查看仓库的状态

commit：提交，指记录工作树中所有文件的当前状态

尚没有可提交的内容，就是说当前我们建立的这个仓库中还没有记录任何文件的任何状态

git add------向暂存区添加文件

要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。

*补充几个概念*
**工作区（Working Directory）就是你在电脑里能看到的目录，比如你的项目文件夹就是一个工作区。工作区里有一个隐藏的 .git 文件夹，这就是Git的版本库（Repository）**

**工作树（Working Tree）是工作区里的一部分，它是Git跟踪和管理的文件的实际内容。工作树中的文件可以是未跟踪的（untracked），已跟踪的（tracked），已修改的（modified），已暂存的（staged）等状态。**

**git仓库的工作树是文件夹，而不是 .git 文件。.git 文件是版本库，它存储了Git的元数据和对象数据库，包括暂存区、分支、标签、HEAD等信息。**

git commit------把暂存区的文件保存到仓库号的历史记录中同时记录自己的评论留言

通过历史记录我们可以从工作树中复原文件

-m 参数后的 "First commit"称作提交信息，是对这个提交的
概述。

如果想要记述得更加详细，请不加 - m，直接执行 g i t c o m m i t命令。执行后编辑器就会启
动，并显示如下结果

/# Please enter the commit message for your changes. Lines starting
/# with '#' will be ignored, and an empty message aborts the commit.
/# On branch master
/#
/# Initial commit

在编辑器中记述提交信息的格式如下。
● 第一行：用一行文字简述提交的更改内容
● 第二行：空行
● 第三行以后：记述更改的原因和详细内容

在以 #（井号）标为注释的 Changes to be committed（要提
交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以 #（井号）标为注释的行不必删除。随后，刚才记述的提交信息就会被提交

**如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。**

git log------查看提交日志

commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值

Author 栏中显示我们给 Git 设置的用户名和邮箱地址。Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息

*如果只想让程序显示第一行简述信息，可以在 git log命令后加上 --pretty=short。这样一来开发人员就能够更轻松地把握多个提交。*

*只显示指定目录、文件的日志只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。*
*如果想查看提交所带来的改动，可以加上 - p参数，文件的前后差别就会显示在提交信息之后*

git log命令可以利用多种参数帮助开发者把握以往
提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就
积极去查，慢慢就能得心应手了。

git diff -----查看工作树，暂存区，最新提交之间的差别

这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。

不妨养成这样一个好习惯：在执行 git commit命令之前先执行
git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提
交的指针

### 分支的操作

并行作业的时候会用到分支。在这类并行开发的过程中，往往同时存在多个最新代码状态。不同分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与 master 分支合并。

**git branch--------显示分支一览表**
**git checkout -b-------创建切换分支**
**git checkout -b <分支名字>**

实际上，连续执行两条命令也能收到同样的效果：
**$git branch <name**
$git checkout <name-------创建A分支同时切换到A分支下

不断对分支的操作，我们叫做“培育分支”
git checkout name---可以切换到想要的分支

在main里我添加一个feature-A分支，feature-A分支中我改动了readme文件，但是在main分支中的readme文件并未被更改，这就是创建分支的优点，只要创建分支，就能在不影响的情况下同时进行多个功能的开发

git checkout -（切换回上一个分支）

特性分支：集中实现单一特性（主题），除此以外不进行任何作业的分支。在日常开发中往往会创建数个特性分支，同时保留一个随时可以发布软件的稳定分支。
稳定分支的角色通常由master担当

我们开发了feature-A分支，这个分支只实现feature-A的功能，如果开发过程中出现了bug，我们就再创建新的分支，在新分支中修复

基于特定主题的作业在特性分支中进行，主题完成以后再与master分支合并。只要保持一个开发流程，就能保证master分支可以随时供人查看。这样其他开发者也可以大胆从master分支中创建新的特性分支

主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用 master 分支作为主干分支。主干分支中并没有开发到一半的代码，可以随时供他人查看。
有时我们需要让这个主干分支总是配置在正式环境中，有时又需要用标签 Tag 等创建版本信息，同时管理多个版本发布。拥有多个版本发布时，主干分支也有多个。

git merge------合并分支
假设我的featu-A分支已经实现完毕，想要将他合并到主干分支master中，首先要切换到master分支中
git checkout master
Switched to branch 'master'
然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合
并，我们需要创建合并提交。因此，在合并时加上 --no-ff参数。
$ git merge --no-ff feature-A
随后编辑器会启动，用于录入合并提交的信息。

默认信息中已经包含了是从 feature-A 分支合并过来的相关内容，所
以可不必做任何更改。将编辑器中显示的内容保存，关闭编辑器，然后就会看到下面的结果

**git log --graph**用于以图表的形式查看分支

### 更改提交的操作

#### git reset————回溯历史版本

Git 的一大特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。

**如何回溯**：
1.回溯到对应状态
要让仓库的HEAD，暂存区，当前工作树回溯的制定的状态，就需要用**git reset --hard**指令

只要提供目标时间点的哈希值，就可以完全恢复到该时间点的状态

git reset --hard  哈希值
之后就可以成功回溯到特征分支创建之前的状态，由于所有的文件都已经回溯到制定哈希值对应的时间点上，README.md文件也恢复到了当时的状态

2.使用fix-B
git checkout -b fix-B------------创建并进入到fix-B分支中

然后修复一些我们想要修复的bug
3.推进到feature-A分支合并后的状态："推进历史"

git log 命令只能查看当前状态为终点的历史日志
git reflog可以查看当前仓库的操作日志，在日志中找出回溯历史之前的哈希值，找出回溯历史之前的哈希值，通过git reset --hard命令恢复到回溯历史之前的状态。

在日志中，我们可以看到 commit、checkout、reset、merge 等 Git 命令的执行记录。只要不进行 Git 的 GC（Garbage Collection，垃圾回收），就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时间点，在过去未来中自由穿梭一般。即便开发者错误执行了 Git 操作，基本也都可以利用 git reflog命令恢复到原先的状态

