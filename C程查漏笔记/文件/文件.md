# 文件

## 文件的概念

保留在外储存器的一组数据的有序组合，C语言中文件是字节流

特点：

* 数据长久保存
* 数据长度不定
* 数据按顺序存取

## 标准文件

标准I/O库中定义了三个特殊的标识符：

1. stdin 标准输入：终端键盘
2. stdout 标准输出：终端显示器
3. stderr 标准出错：终端显示器

三个标准文件在操作系统启动时自动打开，在系统关闭时关闭，器件不允许应用关闭他们

这三个标识符作为FILE*常量可以被所有程序使用

## 文本文件和二进制文件

文本文件：ASCII文件,一个字节存储一个ascii代码（一个ASCII码用8位二进制小数存储）

1BYTE=8bit（bit=一位二进制小数）
1024BYTE=1KB（诸如此类网上递增）

二进制文件：把内存中的数据按照内存的存储形式原样输出到磁盘上存放

所以表示相同的数字，文本文件需要的空间更大，处理花费时间多。但是便于逐个对字符进行处理

二进制文件可以节省外存空间和转换时间，但是一个字节不对应一个字符，不能直接输出字符样式

一般中间结果数据暂时保存在外存上，以后又需要输入内存的，常用未禁止文件保存

## 缓冲文件系统

由于直接把文件写在外存上效率低下，我们设置了缓冲区

由程序控制数据进入缓冲区，再由‘操作系统自己跌完成文件储存

## 非缓冲文件系统

系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区
用非缓冲区系统进行文件系统进行的输入和输出

又称为低级输入输出系统

在UNIX系统中，用缓冲文件系统来处理文本文件，用非缓冲文件系统来处理二进制文件

## ansi c对文件的处理方法

采用缓冲文件系统来处理文本文件和二进制文件
C语言中对文件的读写都是由库函数来实现的
头文件:<stdio.h>

向外输出数据：数据库--->缓冲区------>装满缓冲区之后------>磁盘文件

向外存读取数据：一次性从磁盘中收取一批数据库到缓冲区----->然后再从缓冲区逐个输入读取数据到程序变量

## 文件类型指针

用文件指针表示文件缓冲区

FILE *fp
在缓冲文件系统中，每个被使用的文件都要在内存中开辟一个FILE类文件型的缓冲区，存放文件有关的信息。
同时使用多个文件时，每一个文件都有缓冲区，用不同的文件指针分别指向

FILE  *fp；fp是一个**指向FILE类型结构体**的指针变量。
可以使fp指向某一个文件的结构体变量，从而通过该结构体变量中的文件信息能够访问该文件。

如果有ｎ个文件，一般应设ｎ个指针变量，使它们分别指向n个文件，以实现对文件的访问。

```c
typedef struct{
    short      level;  /* 缓冲区使用量  */
    unsigned      flags;  /* 文件状态标志 */
    char       fd;     /* 文件描述符 */
    short       size; /* 缓冲区大小 */
    unsigned char   *buffer;   /* 文件缓冲区的首地址 */
    unsigned char    *curp;     /* 指向文件缓冲区的工作指针 */
    unsigned char   hold;      /* 其他信息 */
    unsigned      istemp;         
    short       oken;          
} FILE;

```

如何使fp和一个具体文件挂钩：

专门的文件操作函数用于打开、读取、写入和关闭文件，这些函数通常会返回一个文件指针，你可以使用这个文件指针来进行后续的文件操作。

```c
#include <stdio.h>

int main() {
    FILE *fp; // 声明一个文件指针
    char filename[] = "example.txt"; // 文件名

    // 打开文件，如果文件不存在则创建新文件，以只写方式打开
    fp = fopen(filename, "w");

    // 检查文件是否成功打开
    if (fp == NULL) {
        printf("无法打开文件 %s\n", filename);
        return 1;
    }

    // 写入数据到文件
    fprintf(fp, "Hello, world!\n");

    // 关闭文件
    fclose(fp);

    return 0;
}
```

在这个示例中，通过 fopen 函数打开一个名为 "example.txt" 的文件，并指定以只写方式打开。*fopen 函数会返回一个文件指针*，
该文件指针被赋值给变量 fp。

然后，使用 fprintf 函数将字符串 "Hello, world!\n" 写入到文件中。

最后，使用 fclose 函数关闭文件。

这样，文件指针 fp 就与文件 "example.txt" 被挂钩了，

可以使用 fp 变量来对该文件进行后续的读写操作。

### 文件打开

在C语言中，`fopen` 函数用于打开文件，并且可以指定不同的模式（方式）来进行文件的读写操作。以下是 `fopen` 函数常用的文件打开方式：

1. `"r"`：只读模式。文件必须存在，否则会打开失败。文件指针被放置在文件的开头。
2. `"w"`：写入模式。如果文件不存在，则创建新文件；如果文件已存在，则清空文件内容。文件指针被放置在文件的开头。
3. `"a"`：追加模式。如果文件不存在，则创建新文件；如果文件已存在，则在文件末尾追加内容。文件指针被放置在文件的末尾。
4. `"r+"`：读写模式。文件必须存在，否则会打开失败。文件指针被放置在文件的开头。
5. `"w+"`：读写模式。如果文件不存在，则创建新文件；如果文件已存在，则清空文件内容。文件指针被放置在文件的开头。
6. `"a+"`：读写模式。如果文件不存在，则创建新文件；如果文件已存在，则在文件末尾追加内容。文件指针被放置在文件的末尾。

在这些模式中，"+" 表示文件可以读取和写入。例如，"r+" 允许读取和写入文件，而 "w+" 允许读取和写入文件，如果文件不存在则创建新文件，如果文件已存在则清空文件内容。

文件打开使得文件实体和文件指针对应起来

1. 可以在外存中找到这个文件
2. 在内存开辟了一个512字节的缓冲区，并且有fp指向文件缓冲区起始位置
3. 把首块512字节数据：从外存--->缓冲区

检查命令行参数：exit（）函数关闭打开的所有文件并且结束程序，正常结束的程序传递是0，异常结束的程序传递非0值(即使在别的函数中，exit()也能直接结束整个程序)

### 从文件中读取数据

1. 字符读函数：

```C
int fgetc(FILE *FP)
```

2. 字符串读函数：

```C
int fgets(char *string, int n, FILE *fp);
```

3. 格式化读函数:

```C
int fscanf(FILE *fp, char *format, …);
```

4. 二进制(块)读函数：

```C
int fread(char buffer, int size, int count,  FILE *fp);
```

把数据写到文件中

```C
-字符写函数：int fputc(int c, FILE *fp);
-字符串写函数： int fputs(char *string, int n, FILE *fo);
-格式化写函数：int fprintf(FILE *fp, char *format, …);
-二进制(块)写函数：
int fwrite(char *buffer, int size, int count, FILE *fp);
```

#### 主要关注fputc()和fgetc()两个

fputc()函数原型

```c
int fputc(int ch,FILE *fp);
```

功能：把一个字符ch，输入到文件流中

1. 成功：返回写入的值
2. 失败：返回EOF

fgetc()函数原型

```c
int fgetc(FILE *fp);
```

功能：从文件流取出下一个字节并且把他作为一个字符返回，如果达到文件结尾或者出现错误返回EOF

#### fgets() && fputs()

```c
char *fgets(char *buf, int n, FILE *fp);//函数原型
```

功能：从fp所指的文件中读入字符并存到参数buf（buf需要自己定义一个数组？）所指的内存空间，直到出现换行字符、读到文件尾或是已读了n-1个字符
*读取n-1个字符，不是n个，读完n-1个字符的时候，不管buf是否存满，都不再读取*

buf是一个字符串，最后会加上\0作为字符串结束（注意，字符串储存在字符串数组里）
返回值 ：若成功则返回buf指针，返回NULL则表示有错误发生。

使用时注意以下几点：

1. 当遇到换行符或者缓冲区已满，fgets就会停止，返回读到的数据，值得注意的是不能用fgets读二进制文件，因为fgets会把二进制文件当成文本文件来处理，这势必会产生乱码。
2. 每次调用，fgets都会把缓冲区的最后一个字符设为’\0’，这意味着最后一个字符不能用来存放需要的数据，所以**如果有一行，含有LINE_SIZE个字符(包括换行符)，要想把这行读入缓冲区，请把参数n设为LINE_SIZE+1**
3. 由结论1可推出：给定参数n，fgets只能读取n-1个字符(包括换行符)，如果有一行超过n-1个字符，那么fgets返回一个不完整的行，也就是说，只读取该行的前n-1个字符，但是，**缓冲区总是以null字符结尾，对fgets的下一次调用会继续读该行。**

#### fputs()


